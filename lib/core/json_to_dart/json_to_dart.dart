import 'dart:convert';

import 'package:json_to_dart/core/utils/string_extenstions.dart';

///TODO: impletement enum x
///TODO implement copywith
//todo: make all field final
//TODO: use freezed package and json_to_dart package

class JsonToDart {
  static String _baseClassName = "AutoGeneratedDartModel";
  static late bool _makeAllFieldNullable;
  static late bool _makeAllFieldOptional;
  static late bool _implementEquatable;
  static late bool _addTrailingUnderscore;
  static late bool _addCopyWith;
  static late bool _shouldBeMutable;
  static late bool _useFreezed;

  /// if _makeAllFieldOptional is true, all fields will be nullable since the non nullable fields have to be initialized whatever be the value of makeAllFieldNullable
  /// here
  /// [makeAllFieldOptional] =[true] and [makeAllFieldNullable] = [true]
  ///
  /// [makeAllFieldOptional] =[true] and [makeAllFieldNullable] = [false]
  /// results in same result
  static String generate(
    String jsonString, {
    String baseClass = "AutogeneratedDartModel",
    bool makeAllFieldNullable = false,
    bool makeAllFieldOptional = false,
    bool implementEquatable = false,
    bool addTrailingUnderscore = false,
    bool addCopyWith = false,
    bool shouldBeMutable = false,
    bool useFreezed = false,
  }) {
    _makeAllFieldNullable = makeAllFieldNullable;
    _makeAllFieldOptional = makeAllFieldOptional;
    _implementEquatable = implementEquatable;
    _addTrailingUnderscore = addTrailingUnderscore;
    _addCopyWith = addCopyWith;
    _shouldBeMutable = shouldBeMutable;
    _useFreezed = useFreezed;

    if (_useFreezed) {
      _implementEquatable = false;
    }

    if (_implementEquatable) {
      _shouldBeMutable = false;
    }

    if (_makeAllFieldOptional) {
      _makeAllFieldNullable = true;
    }

    _baseClassName = baseClass;
    final classed = _extractSingleMapFromNestedmap(jsonDecode(jsonString));
    String dart = '''
    ${_useFreezed ? "// ignore_for_file: invalid_annotation_target" : ""}
    
    
    ${_getImports()}''';
    classed?.forEach((className, value) {
      final fields = _getFields(value, parentKey: className);
      final constructor = _getConstructor(value, parentKey: className);
      if (_useFreezed) {
        dart += '''
     ${_shouldBeMutable ? "@unfreezed" : "@freezed"} 
      class ${_getTypeName(className)} with _\$${_getTypeName(className)}{
      const factory ${_getTypeName(className)}({
       $fields 
      })= _${_getTypeName(className)};
      
        factory ${_getTypeName(className)}.fromJson(Map<String, dynamic> json) => _\$${_getTypeName(className)}FromJson(json);
      } 
      ''';
      } else {
        dart +=
            '''class ${_getTypeName(className)} ${_implementEquatable ? 'extends Equatable' : ''} {
            
            $fields
            
            $constructor
            
            ${_getFromJson(value, parentKey: className)}
            
            ${_getToJson(value, parentKey: className)}
            
            ${_addCopyWith ? _getCopyWith(value, parentKey: className) : ''}
            
            ${_implementEquatable ? _getEqutableProps(value, parentKey: className) : ''} 
            
            }
            ''';
      }
    });

    return dart;
  }

  /// get the imports for the generated dart source code
  static String _getImports() {
    String import = '';
    if (_implementEquatable) {
      import += "import 'package:equatable/equatable.dart';";
    }

    if (_useFreezed) {
      import += '''
      import 'package:freezed_annotation/freezed_annotation.dart';
      
      part '${_getFileName(_baseClassName)}.freezed.dart';
      part '${_getFileName(_baseClassName)}.g.dart';

      ''';
    }

    return import;
  }

  /// get the fields fo the class.
  /// get defination of properties and their types
  /// get defination of constructor with [this].
  static String _getFields<T>(
    T json, {
    required String parentKey,
    bool withoutTypes = false,
    bool withoutFinalKeyword = false,
    bool nullCheck = false,
  }) {
    if (json is! Map) {
      if (_useFreezed) {
        return "@JsonKey(name:'$parentKey') ${_makeAllFieldOptional ? '' : 'required'} ${_getTypes<T>(json, key: parentKey)} ${_makeAllFieldOptional ? '?' : ''} ${_getFieldName(parentKey)},\n";
      }

      if (nullCheck) {
        return "${_getFieldName(parentKey)}??this.${_getFieldName(parentKey)},";
      }

      if (withoutTypes) {
        return "${_makeAllFieldOptional ? '' : 'required'} this.${_getFieldName(parentKey)},";
      }

      return "${withoutFinalKeyword ? '' : _shouldBeMutable ? '' : 'final'} ${_getTypes<T>(json, key: parentKey)}${_makeAllFieldNullable ? _getTypes<T>(json, key: parentKey) == 'dynamic' ? '' : '?' : ''} ${_getFieldName(parentKey)} ${withoutFinalKeyword ? ',' : ';'}\n";
    }

    String dartCodeForFields = "";

    json.forEach(
      (key, value) {
        if (value is! Map) {
          final newCode = _getFields<T>(
            value,
            parentKey: key,
            withoutTypes: withoutTypes,
            withoutFinalKeyword: withoutFinalKeyword,
            nullCheck: nullCheck,
          );
          dartCodeForFields += newCode;
          return;
        }

        if (_useFreezed) {
          dartCodeForFields +=
              "@JsonKey(name:'$key') ${_makeAllFieldOptional ? '' : 'required'} ${_getTypes<T>(json, key: key)} ${_makeAllFieldOptional ? '?' : ''} ${_getFieldName(key)},\n";
        } else if (nullCheck) {
          dartCodeForFields +=
              "${_getFieldName(key)}??this.${_getFieldName(key)},";
        } else {
          dartCodeForFields += (withoutTypes)
              ? "${_makeAllFieldOptional ? '' : 'required'} this.${_getFieldName(key)},"
              : "${withoutFinalKeyword ? '' : _shouldBeMutable ? '' : 'final'} ${_getTypes(value, key: key)}${_makeAllFieldNullable ? '?' : ''} ${_getFieldName(key)} ${withoutFinalKeyword ? ',' : ';'}\n";
        }
      },
    );

    return dartCodeForFields;
  }

  static String _getFieldsNameOnly<T>(T json, {required String parentKey}) {
    if (json is! Map) {
      return _getFieldName(parentKey);
    }

    String dartCodeForFields = "";
    json.forEach((key, value) {
      if (value is! Map) {
        final newCode = _getFieldsNameOnly<T>(value, parentKey: key);
        dartCodeForFields += '$newCode,\n';
        return;
      }
      dartCodeForFields += "${_getFieldName(key)},\n";
    });

    return dartCodeForFields;
  }

// TODO: implement copyWith
  static String _getCopyWith<T>(
    T json, {
    required String parentKey,
  }) {
    final parameters =
        _getFields(json, parentKey: parentKey, withoutFinalKeyword: true);
    final createNew = _getFields(json, parentKey: parentKey, nullCheck: true);
    return '''${_getTypeName(parentKey)} copyWith($parameters){
  return ${_getTypeName(parentKey)}({$createNew});
  }
   ''';
  }

  /// genereate from json method
  static String _getFieldsFromJson<T>(T json, {required String parentKey}) {
    if (json is String && _isFormatedStringDate(json)) {
      return '''${_getFieldName(parentKey)}: ${_makeAllFieldNullable ? 'DateTime.tryParse(json["$parentKey"]' : 'DateTime.parse(json["$parentKey"]'} ),\n''';
    }
    if (json is List && json.isNotEmpty && json.first is Map) {
      return '''${_getFieldName(parentKey)}:${_makeAllFieldNullable ? 'json["$parentKey"]!=null?' : ''}  List<${_getTypeName(parentKey)}>.from(json["$parentKey"].map((x) => ${_getTypeName(parentKey)}.fromJson(x))) ${_makeAllFieldNullable ? ':null' : ''},\n''';
    }
    if (json is! Map) {
      return '''${_getFieldName(parentKey)}:json["$parentKey"],\n''';
    }

    String dartCodeForFields = "";
    json.forEach((key, value) {
      if (value is! Map) {
        final newCode = _getFieldsFromJson<T>(value, parentKey: key);
        dartCodeForFields += newCode;
        return;
      }

      dartCodeForFields +=
          '''${_getFieldName(key)}:${_makeAllFieldNullable ? 'json["$key"]!=null?' : ''} ${_getTypeName(key)}.fromJson(json["$key"])${_makeAllFieldNullable ? ':null' : ''},\n''';
    });

    return dartCodeForFields;
  }

  /// generate to json method
  static String _getFieldsToJson<T>(T json, {required String parentKey}) {
    if (json is String && _isFormatedStringDate(json)) {
      return '''"$parentKey":${_getFieldName(parentKey)}${_makeAllFieldNullable ? '?' : ''}.toIso8601String(),\n''';
    }
    if (json is List && json.isNotEmpty && json.first is Map) {
      return '''"$parentKey":${_getFieldName(parentKey)}${_makeAllFieldNullable ? '?' : ''}.map((x) => x.toJson()).toList(),\n''';
    }
    if (json is! Map) {
      return '''"$parentKey": ${_getFieldName(parentKey)},\n''';
    }

    String dartCodeForFields = "";
    json.forEach((key, value) {
      if (value is! Map) {
        final newCode = _getFieldsToJson<T>(value, parentKey: key);
        dartCodeForFields += newCode;
        return;
      }

      dartCodeForFields +=
          '''"$key": ${_getFieldName(key)}${_makeAllFieldNullable ? '?' : ''}.toJson(),\n ''';
    });

    return dartCodeForFields;
  }

  /// get constructor for the class.
  static String _getConstructor<T>(T json, {required String parentKey}) {
    final fields = _getFields(json, parentKey: parentKey, withoutTypes: true);
    return '''${_getTypeName(parentKey)}( ${fields.trim().isNotEmpty ? '{$fields}' : ''});''';
  }

  static _getFromJson<T>(T json, {required String parentKey}) {
    return "factory ${_getTypeName(parentKey)}.fromJson(Map<String, dynamic> json) => ${_getTypeName(parentKey)}(\n${_getFieldsFromJson(json, parentKey: parentKey)});";
  }

  static _getToJson<T>(T json, {required String parentKey}) {
    return "Map<String, dynamic> toJson() => {\n${_getFieldsToJson(json, parentKey: parentKey)}};";
  }

  static String _getEqutableProps<T>(T json, {required String parentKey}) {
    return '''@override\nList<Object${_makeAllFieldNullable ? '?' : ''}> get props => [${_getFieldsNameOnly(json, parentKey: parentKey)}];\n''';
  }

  /// get the name for field from the key with camelCase and modifcation to match with keyword
  static String _getFieldName(String key) {
    return "${(key).camelCase()}${_addTrailingUnderscore ? '_' : ''}";
  }

  static String _getFileName(String key) {
    return key.snackCase();
  }

  /// get the Type for field from the key with camelCase and modifcation to match with keyword
  static String _getTypeName(String key) {
    return (key).pascalCase();
  }

  /// get the type for field
  static String _getTypes<T>(T value, {String? key}) {
    if (value == null) return 'dynamic';

    if (value is List) {
      return "List<${value.isNotEmpty ? _getTypes(value.first, key: key) : 'dynamic'}>";
    } else if (value is Map) {
      return _getTypeName(key ?? "Map");
    } else if (value is Set) {
      return "Set<${value.isNotEmpty ? _getTypes(value.first, key: key) : 'dynamic'}>";
    } else if (value is Enum) {
      return _getTypeName(key ?? 'Enum');
    } else if (value is String) {
      return _isFormatedStringDate(value) ? "DateTime" : "String";
    } else {
      return value.runtimeType.toString();
    }
  }

  /// check if the string is formatted datetime
  static bool _isFormatedStringDate(String formatedString) =>
      DateTime.tryParse(formatedString) != null;

  /// extract potential classes from the nested map
  static Map? _extractSingleMapFromNestedmap(json, {String? key}) {
    final classes = {};
    if (json is Map) {
      classes.addAll({key ?? _baseClassName: json});

      json.forEach((key, value) {
        final newClasses = _extractSingleMapFromNestedmap(value, key: key);
        if (newClasses != null) {
          classes.addAll(newClasses);
        }
      });
    }

    if (json is List) {
      final tempJson = {};

      if (json.isNotEmpty && json.first is Map) {
        for (var value in json) {
          tempJson.addAll(value);
        }
        final newClasses = _extractSingleMapFromNestedmap(tempJson, key: key);
        if (newClasses != null) {
          classes.addAll(newClasses);
        }
      } else {
        for (var value in json) {
          final newClasses = _extractSingleMapFromNestedmap(value, key: key);
          if (newClasses != null) {
            classes.addAll(newClasses);
          }
        }
      }
    }

    return classes;
  }
}
